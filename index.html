<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js physics - ammo.js AmmoPhysics</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> physics - ammo.js AmmoPhysics
		</div>

		<script src="js/ammo.wasm.js"></script>
		<script type="module">

			import * as THREE from './js/build/three.module.js';
			import { OrbitControls } from './js/examples/jsm/controls/OrbitControls.js';
			import { AmmoPhysics } from './js/physics.js';
			import Stats from './js/examples/jsm/libs/stats.module.js';
			import { TeapotGeometry } from './js/examples/jsm/geometries/TeapotGeometry.js';
			
			let camera, scene, renderer, stats;
			let physics;
			const markers = [];
			const bodies = [];
			const meshes = [];
			let tempMesh;
			let tempBody;
			const velocity = new THREE.Vector3();
			const angular = new THREE.Vector3();
			const contact = new THREE.Vector3();
			let lastTime = 0;

			init();
			async function init() {

				//Scene
				//-----------------------------------------------------------------------------------------------
				
				physics = await AmmoPhysics();

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 50 );
				camera.position.set( 0, 3, -3 );
				camera.lookAt( 0, 0.5, 0 );
				
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x5e5e5e );

				var light = new THREE.HemisphereLight();
				light.intensity = 0.35;
				scene.add( light );

				var light = new THREE.DirectionalLight();
				light.position.set( 5, 5, 5 );
				light.castShadow = true;
				light.shadow.camera.zoom = 2;
				scene.add( light );


				//Meshes and bodies
				//-----------------------------------------------------------------------------------------------
				var smooth = new THREE.MeshPhongMaterial( { color: 0x1f3a70 } );
				var flat = new THREE.MeshPhongMaterial( { color: 0x1f3a70, flatShading:true } );

				//0-3 Invisibles walls
				var rot = [0,90,180,-90], scale = 3;
				var geometry = new THREE.PlaneGeometry( scale, scale, 1 );
				
				for ( var i = 0; i < 4; i++ ) {
				
				tempMesh = meshes.push(new THREE.Mesh( geometry ));
				meshes[tempMesh-1].rotateY(rot[i]*Math.PI/180);
				meshes[tempMesh-1].translateZ(-1*scale/2);
				meshes[tempMesh-1].visible = false;
				meshes[tempMesh-1].mass = 0;
				tempBody = bodies.push(meshes[tempMesh-1]);
				}

				//4 Static floor
				tempMesh = meshes.push(new THREE.Mesh( new THREE.PlaneGeometry( scale, scale, 1 ),
				new THREE.MeshPhongMaterial( { color: 0xafafaf } )));
				meshes[tempMesh-1].rotation.x = - Math.PI / 2;
				meshes[tempMesh-1].receiveShadow = true;
				meshes[tempMesh-1].mass = 0;
				tempBody = bodies.push(meshes[tempMesh-1]);
				
				//5 Teapot using a Compound Shape body
				tempMesh = meshes.push(new THREE.Mesh( new TeapotGeometry( 5, 5 ), smooth ));
				meshes[tempMesh-1].position.set( -1, 0.5, 1 );
				meshes[tempMesh-1].scale.set(0.04,0.04,0.04);
				meshes[tempMesh-1].mass = 2;
				
				tempBody = bodies.push(new THREE.Group());
				var tank = new THREE.Mesh( new THREE.CylinderGeometry (0.25, 0.25, 0.4, 24 ));
				var handle = new THREE.Mesh( new THREE.BoxGeometry( 0.8, 0.3, 0.03 ));
				bodies[tempBody-1].add(tank);
				bodies[tempBody-1].add(handle);
				
				//6 Sphere 
				tempMesh = meshes.push(new THREE.Mesh(new THREE.SphereGeometry( 0.23, 24, 24 ), smooth ));
				meshes[tempMesh-1].position.set( 1, 0.5, 1 );
				meshes[tempMesh-1].mass = 2;
				tempBody = bodies.push(meshes[tempMesh-1]);
				
				//7 Cylinder				
				tempMesh = meshes.push(new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.4, 24 ), smooth ));
				meshes[tempMesh-1].position.set( 0, 0.5, 0 );
				meshes[tempMesh-1].mass = 2;
				tempBody = bodies.push(meshes[tempMesh-1]);
				
				//8 Cone
				tempMesh = meshes.push(new THREE.Mesh(new THREE.ConeGeometry(0.3, 0.5, 24 ), smooth ));
				meshes[tempMesh-1].position.set( 1, 0.5, -1 );
				meshes[tempMesh-1].mass = 2;
				tempBody = bodies.push(meshes[tempMesh-1]);
				
				//9 Convex hull shape (example: cone shaped THREE cylinder)
				tempMesh = meshes.push(new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 0.3, 5 ), flat ));
				meshes[tempMesh-1].position.set( 0, 0.5, -1 );
				meshes[tempMesh-1].mass = 2;
				tempBody = bodies.push(meshes[tempMesh-1]);
				
				//10 Instanced boxes
				tempMesh = meshes.push(new THREE.InstancedMesh( new THREE.BoxGeometry( 0.2, 0.2, 0.2 ),
				new THREE.MeshPhongMaterial( { color: 0x1f3a70 } ), 3 ));
				meshes[tempMesh-1].mass = 2;
				meshes[tempMesh-1].userData.pos = [];	
	
				for ( var i = 0; i < meshes[tempMesh-1].count; i ++ ) {
				meshes[tempMesh-1].userData.pos[i] = new THREE.Vector3();
				meshes[tempMesh-1].userData.pos[i].set( 1, 0.5, 0 );
				}
				
				tempBody = bodies.push(meshes[tempMesh-1]);

				//Physics setup
				//-----------------------------------------------------------------------------------------------
				
				for ( let i in meshes ) {
					
					meshes[i].index = i;
					
					//shadows
					meshes[i].traverse( function ( child ) {
						if (meshes[i].visible == true && child.isMesh) {
						child.castShadow = true;
						}
					});

					physics.addMesh( meshes[i], bodies[i], meshes[i].mass );
					
					//instance positions
					if ( meshes[i].isInstancedMesh ) {
						for ( var j = 0; j < meshes[i].count; j++ ){
							physics.setMeshPosition( meshes[i], meshes[i].userData.pos[j], meshes[i].quaternion, j );
						}
					//meshes positions
					} else {
						physics.setMeshPosition( meshes[i], meshes[i].position, meshes[i].quaternion, 0);
					}
					
					if (meshes[i].visible == true) {scene.add( meshes[i] );}
				}
			
				//markers
				var geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) ] );
				for (var i = 0; i < meshes.length; i++) {
					var line = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: 0xff0000 } ));
					line.visible = false;
					scene.add( line );
					markers[i] = line;
				}
				
				//Renderer
				//-----------------------------------------------------------------------------------------------				
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				renderer.outputEncoding = THREE.sRGBEncoding;
				document.body.appendChild( renderer.domElement );

				stats = new Stats();
				document.body.appendChild( stats.dom );

				var controls = new OrbitControls( camera, renderer.domElement );
				controls.target.y = 0.5;
				controls.update();
				
				animate();
			}
			
			function animate() {
			
				requestAnimationFrame( animate );
				renderer.render( scene, camera );
				stats.update();
				
				var now = performance.now();
				var timesince = now - lastTime;
				
				//velocity and angular rotation change every 2 seconds 
				if (timesince > 2000) {
					for ( var i = 0; i < meshes.length; i++ ) {
						
							velocity.set( Math.random() * 2-1, 4, Math.random() * 2-1 );
							angular.set( Math.random() *6, Math.random() *6, Math.random() *6 );

							if ( meshes[i].isInstancedMesh ) {
								for ( var j = 0; j < meshes[i].count; j++ ){
								physics.setMeshVelocity( meshes[i], velocity, angular, j );
								}
							} else { physics.setMeshVelocity( meshes[i], velocity, angular, i );}
						}
				}

				if (timesince > 2100) {
					//reset contact flags when objects are mid-air
					for (var i = 0; i < meshes.length; i++) {
						markers[i].visible = false;
					}
					
					lastTime = performance.now();
				}
				// CONTACT DETECTION SETUP
				//1.all meshes contact against a single mesh (mesh, markers)
				//2.contacts received on a single mesh ( mesh, contact )
				//3.contacts between two meshes ( meshA, meshB, contact )
				//---------------------------------------------------
				
			//1
				//physics.getAllCollisions(meshes[4], markers);
				
			//2
			
			//	physics.getContactPair( meshes[5], contact );
			//	markers[0].visible = true;
			//	markers[0].position.copy(contact);
			
			//3
				physics.getContact(meshes[5], meshes[4], contact);
				markers[0].visible = true;
				markers[0].position.copy(contact);

			}
		</script>
	</body>
</html>